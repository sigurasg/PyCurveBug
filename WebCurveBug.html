<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebCurveBug - Web Serial Version</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: Arial, sans-serif;
    background-color: #000000;
    color: #ffffff;
    overflow: hidden;
    user-select: none;
}

.connection-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #1e1e1e;
    border: 3px solid #646464;
    padding: 30px;
    z-index: 3000;
    min-width: 400px;
}

.connection-panel.hidden {
    display: none;
}

.connection-title {
    font-size: 24px;
    margin-bottom: 20px;
    text-align: center;
}

.connection-button {
    width: 100%;
    padding: 15px;
    margin: 10px 0;
    background-color: #3296ff;
    color: #ffffff;
    border: 2px solid #ffffff;
    font-size: 16px;
    cursor: pointer;
}

.connection-button:hover {
    background-color: #5aafff;
}

.connection-button.disconnect {
    background-color: #ff3232;
}

.connection-button.disconnect:hover {
    background-color: #ff5a5a;
}

.connection-status {
    text-align: center;
    margin: 15px 0;
    padding: 10px;
    background-color: #323232;
    border-radius: 5px;
}

.port-info {
    font-size: 12px;
    color: #c8c8c8;
    margin: 10px 0;
}

.main-container {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
}

.status-bar {
    padding: 5px 20px;
    background-color: #000000;
    border-bottom: 1px solid #333333;
}

.status-line {
    font-size: 12px;
    color: #646464;
    margin: 2px 0;
}

.serial-status {
    float: right;
    font-weight: bold;
}

.serial-status.connected {
    color: #32ff96;
}

.serial-status.disconnected {
    color: #ff3232;
}

.plot-area {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 20px;
    position: relative;
}

.plot-container {
    position: relative;
    width: calc(100% - 100px);
    height: calc(100% - 100px);
    max-width: 1200px;
    max-height: 1200px;
}

.plot-title {
    position: absolute;
    top: -40px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    color: #ffffff;
    white-space: nowrap;
}

.canvas-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    background-color: #1e1e1e;
    border: 2px solid #646464;
}

canvas {
    display: block;
    width: 100%;
    height: 100%;
}

.axis-label-x {
    position: absolute;
    bottom: -50px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    color: #ffffff;
}

.axis-label-y {
    position: absolute;
    left: -80px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 18px;
    color: #ffffff;
    writing-mode: vertical-lr;
    transform: rotate(180deg) translateX(50%);
}

.info-panel {
    padding: 10px 20px;
    background-color: #000000;
    border-top: 1px solid #333333;
    font-size: 12px;
}

.info-line {
    margin: 3px 0;
}

.info-line.ch1 {
    color: #3296ff;
}

.info-line.ch2 {
    color: #ff3232;
}

.info-line.voltage {
    color: #32ff96;
}

.legend {
    position: absolute;
    top: 20px;
    left: 20px;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border: 1px solid #646464;
}

.legend-item {
    display: flex;
    align-items: center;
    margin: 8px 0;
    font-size: 14px;
}

.legend-line {
    width: 40px;
    height: 4px;
    margin-right: 10px;
}

.legend-line.dut1 {
    background-color: #3296ff;
}

.legend-line.dut2 {
    background-color: #ff3232;
}

.pause-overlay {
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: rgba(0, 0, 0, 0.8);
    padding: 20px 40px;
    font-size: 48px;
    color: #ffff32;
    font-weight: bold;
    border: 3px solid #ffff32;
}

.pause-overlay.active {
    display: block;
}

.connect-button-top {
    position: fixed;
    top: 2.5px;
    right: 200px;
    padding: 10px 20px;
    background-color: #3296ff;
    color: #ffffff;
    border: 2px solid #ffffff;
    font-size: 14px;
    cursor: pointer;
    z-index: 100;
}

.connect-button-top:hover {
    background-color: #5aafff;
}

.connect-button-top.connected {
    background-color: #32ff96;
    color: #000000;
}

.settings-button {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 10px 20px;
    background-color: #323232;
    color: #ffffff;
    border: 2px solid #ffffff;
    cursor: pointer;
    font-size: 14px;
    z-index: 100;
}

.settings-button:hover {
    background-color: #505050;
}

.settings-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000000;
    z-index: 1000;
    overflow-y: auto;
}

.settings-overlay.active {
    display: block;
}

.settings-header {
    background-color: #1e1e1e;
    padding: 20px;
    border-bottom: 2px solid #646464;
    text-align: center;
}

.settings-title {
    font-size: 32px;
    color: #ffffff;
}

.settings-tabs {
    display: flex;
    justify-content: center;
    gap: 15px;
    padding: 20px;
}

.tab-button {
    padding: 12px 30px;
    background-color: #323232;
    color: #ffffff;
    border: 2px solid #ffffff;
    cursor: pointer;
    font-size: 14px;
}

.tab-button:hover {
    background-color: #505050;
}

.tab-button.active {
    background-color: #3296ff;
}

.settings-content {
    padding: 40px;
    max-width: 1200px;
    margin: 0 auto;
}

.tab-panel {
    display: none;
}

.tab-panel.active {
    display: block;
}

.settings-group {
    margin-bottom: 30px;
}

.settings-row {
    display: flex;
    align-items: center;
    margin: 20px 0;
    gap: 20px;
}

.settings-label {
    min-width: 180px;
    font-size: 16px;
    color: #ffffff;
}

.settings-input {
    padding: 10px;
    background-color: #1e1e1e;
    color: #ffffff;
    border: 2px solid #646464;
    font-size: 14px;
    width: 200px;
}

.settings-input:focus {
    border-color: #ffffff;
    outline: none;
}

.color-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 20px;
}

.color-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px;
}

.color-swatch {
    width: 100px;
    height: 35px;
    border: 2px solid #646464;
    cursor: pointer;
}

.color-swatch:hover {
    border-color: #ffffff;
}

.info-box {
    padding: 20px;
    background-color: #1e1e1e;
    border: 2px solid #ffff32;
    margin-top: 20px;
}

.info-box.blue {
    border-color: #3296ff;
}

.info-text {
    color: #c8c8c8;
    font-size: 14px;
    line-height: 1.6;
}

.info-text.warning {
    color: #ffff32;
}

.settings-footer {
    display: flex;
    justify-content: center;
    gap: 20px;
    padding: 30px;
    border-top: 2px solid #646464;
}

.button {
    padding: 15px 40px;
    font-size: 16px;
    border: 2px solid #ffffff;
    cursor: pointer;
    color: #ffffff;
}

.button.save {
    background-color: #32ff96;
    color: #000000;
    border-color: #32ff96;
}

.button.save:hover {
    background-color: #5aff9f;
}

.button.cancel {
    background-color: #ff3232;
    border-color: #ff3232;
}

.button.cancel:hover {
    background-color: #ff5a5a;
}

.color-picker-dialog {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 400px;
    background-color: #1e1e1e;
    border: 3px solid #ffffff;
    padding: 20px;
    z-index: 2000;
}

.color-picker-dialog.active {
    display: block;
}

.color-picker-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    z-index: 1999;
}

.color-picker-overlay.active {
    display: block;
}

.color-picker-title {
    font-size: 20px;
    margin-bottom: 20px;
    color: #ffffff;
}

.slider-group {
    margin: 15px 0;
}

.slider-label {
    display: inline-block;
    width: 70px;
    color: #ffffff;
}

.slider-container {
    display: inline-block;
    width: 250px;
    position: relative;
    margin: 0 10px;
}

.color-slider {
    width: 100%;
    height: 20px;
    background: #323232;
    border: 1px solid #646464;
    appearance: none;
    cursor: pointer;
}

.color-slider::-webkit-slider-thumb {
    appearance: none;
    width: 15px;
    height: 20px;
    background: #ffffff;
    cursor: pointer;
}

.color-slider::-moz-range-thumb {
    width: 15px;
    height: 20px;
    background: #ffffff;
    cursor: pointer;
    border: none;
}

.slider-value {
    display: inline-block;
    width: 40px;
    color: #ffffff;
}

.color-preview {
    width: 80px;
    height: 80px;
    border: 2px solid #ffffff;
    margin: 20px auto;
}

.picker-buttons {
    display: flex;
    gap: 10px;
    margin-top: 20px;
}

.picker-buttons .button {
    flex: 1;
    padding: 10px;
}

@media (max-width: 768px) {
    .color-grid {
        grid-template-columns: 1fr;
    }

    .settings-tabs {
        flex-wrap: wrap;
    }

    .tab-button {
        flex: 1 1 40%;
    }
}
</style>
</head>
<body>

<button class="connect-button-top" id="connectButtonTop">Connect Serial</button>
<button class="settings-button" id="settingsButton">Settings</button>

<div class="connection-panel hidden" id="connectionPanel">
    <div class="connection-title">Serial Connection</div>
    <div class="connection-status" id="connectionStatus">Not connected</div>
    <div class="port-info" id="portInfo">Click below to select a serial port</div>
    <button class="connection-button" id="selectPortButton">Select Serial Port</button>
    <button class="connection-button disconnect hidden" id="disconnectButton">Disconnect</button>
    <button class="connection-button" id="closeConnectionPanel">Close</button>
</div>

<div class="settings-overlay" id="settingsOverlay">
    <div class="settings-header">
        <h1 class="settings-title" id="settingsTitle">Display Settings</h1>
    </div>

    <div class="settings-tabs">
        <button class="tab-button active" data-tab="display">Display</button>
        <button class="tab-button" data-tab="colors">Colors</button>
        <button class="tab-button" data-tab="keybinds">Keybinds</button>
        <button class="tab-button" data-tab="about">About</button>
    </div>

    <div class="settings-content">
        <div class="tab-panel active" id="displayPanel">
            <div class="settings-group">
                <div class="settings-row">
                    <label class="settings-label">Acquisition Rate:</label>
                    <input type="number" class="settings-input" id="acqRate" value="35" min="1" max="100">
                    <span class="settings-label">Hz</span>
                </div>
            </div>
            <div class="info-box blue">
                <p class="info-text">Adjust how frequently data is acquired from the CurveBug. Higher rates provide smoother updates but may increase CPU usage.</p>
                <p class="info-text">Higher rates also can cause glitches in data view randomly. Good known values are 35Hz and below.</p>
                <p class="info-text">Your mileage may vary, for example 50Hz works and rarely sees glitches.</p>
            </div>
        </div>

        <div class="tab-panel" id="colorsPanel">
            <div class="color-grid" id="colorGrid">
                <div class="color-item">
                    <span class="settings-label">Background</span>
                    <div class="color-swatch" data-color="background" style="background-color: rgb(0,0,0)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">DUT1 Trace (Blue)</span>
                    <div class="color-swatch" data-color="dut1_trace" style="background-color: rgb(50,150,255)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">DUT2 Trace (Red)</span>
                    <div class="color-swatch" data-color="dut2_trace" style="background-color: rgb(255,50,50)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">DUT1 Dimmed</span>
                    <div class="color-swatch" data-color="dut1_dimmed" style="background-color: rgb(25,75,128)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">DUT2 Dimmed</span>
                    <div class="color-swatch" data-color="dut2_dimmed" style="background-color: rgb(128,25,25)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Grid Background</span>
                    <div class="color-swatch" data-color="grid_background" style="background-color: rgb(30,30,30)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Grid Lines</span>
                    <div class="color-swatch" data-color="grid" style="background-color: rgb(50,50,50)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Crosshair</span>
                    <div class="color-swatch" data-color="crosshair" style="background-color: rgb(255,255,50)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Axis Labels</span>
                    <div class="color-swatch" data-color="label" style="background-color: rgb(200,200,200)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Axis Titles</span>
                    <div class="color-swatch" data-color="axis_title" style="background-color: rgb(255,255,255)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">Border</span>
                    <div class="color-swatch" data-color="border" style="background-color: rgb(100,100,100)"></div>
                </div>
                <div class="color-item">
                    <span class="settings-label">DUT Voltage</span>
                    <div class="color-swatch" data-color="dut_voltage" style="background-color: rgb(50,255,150)"></div>
                </div>
            </div>
            <div style="display: flex; gap: 20px; margin: 20px 0; justify-content: center;">
                <button class="button" id="darkModeButton" style="background-color: #323232; padding: 12px 30px;">Apply Dark Theme</button>
                <button class="button" id="lightModeButton" style="background-color: #e0e0e0; color: #000; padding: 12px 30px;">Apply Light Theme</button>
            </div>
            <div class="info-box blue">
                <p class="info-text">Click any color box to customize</p>
            </div>
        </div>

        <div class="tab-panel" id="keybindsPanel">
            <div class="color-grid">
                <div class="settings-row">
                    <label class="settings-label">Quit:</label>
                    <input type="text" class="settings-input" id="keyQuit" value="q" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Pause:</label>
                    <input type="text" class="settings-input" id="keyPause" value="p" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Single Channel:</label>
                    <input type="text" class="settings-input" id="keySingle" value="s" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Auto Scale:</label>
                    <input type="text" class="settings-input" id="keyAuto" value="a" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Fit Window:</label>
                    <input type="text" class="settings-input" id="keyFit" value="f" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Reset View:</label>
                    <input type="text" class="settings-input" id="keyReset" value="r" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Cycle Mode:</label>
                    <input type="text" class="settings-input" id="keyCycle" value="space" maxlength="5">
                </div>
                <div class="settings-row">
                    <label class="settings-label">Settings:</label>
                    <input type="text" class="settings-input" id="keySettings" value="f1" maxlength="5">
                </div>
            </div>
            <div class="info-box blue">
                <p class="info-text">Click a keybind box and type the new key</p>
                <p class="info-text">Supported: letters (a-z), space, f1-f12, escape</p>
            </div>
        </div>

        <div class="tab-panel" id="aboutPanel">
            <div class="info-box blue">
                <h2 style="margin-bottom: 15px;">WebCurveBug</h2>
                <p class="info-text">Curve Viewer for vintageTEK CurveBug</p>
                <p class="info-text" style="margin-top: 10px;">Features:</p>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li class="info-text">Dual I-V curve display</li>
                    <li class="info-text">Web Serial API for direct hardware connection</li>
                    <li class="info-text">Inverted axes per CurveBug manual</li>
                    <li class="info-text">Pan and zoom navigation</li>
                    <li class="info-text">Auto-scale and fixed scale modes</li>
                    <li class="info-text">Configurable colors and keybinds</li>
                    <li class="info-text">Multiple excitation modes (4.7K, 100K, ALT)</li>
                </ul>
            </div>
            <div class="info-box" style="margin-top: 20px;">
                <p class="info-text warning">Browser Requirements:</p>
                <p class="info-text">Chrome 89+, Edge 89+, Opera 76+, (and other Chromium-based browsers).</p>
                <p class="info-text">Web Serial API not supported in Firefox or Safari</p>
                <p class="info-text">Page must be served over HTTPS or localhost</p>
            </div>
        </div>
    </div>

    <div class="settings-footer">
        <button class="button save" id="saveButton">Save</button>
        <button class="button cancel" id="cancelButton">Cancel</button>
    </div>
</div>

<div class="color-picker-overlay" id="colorPickerOverlay"></div>
<div class="color-picker-dialog" id="colorPickerDialog">
    <div class="color-picker-title">Choose Color</div>
    <div class="slider-group">
        <span class="slider-label">Red:</span>
        <div class="slider-container">
            <input type="range" class="color-slider" id="redSlider" min="0" max="255" value="0">
        </div>
        <span class="slider-value" id="redValue">0</span>
    </div>
    <div class="slider-group">
        <span class="slider-label">Green:</span>
        <div class="slider-container">
            <input type="range" class="color-slider" id="greenSlider" min="0" max="255" value="0">
        </div>
        <span class="slider-value" id="greenValue">0</span>
    </div>
    <div class="slider-group">
        <span class="slider-label">Blue:</span>
        <div class="slider-container">
            <input type="range" class="color-slider" id="blueSlider" min="0" max="255" value="0">
        </div>
        <span class="slider-value" id="blueValue">0</span>
    </div>
    <div class="color-preview" id="colorPreview"></div>
    <div class="picker-buttons">
        <button class="button save" id="pickerOK">OK</button>
        <button class="button cancel" id="pickerCancel">Cancel</button>
    </div>
</div>

<div class="main-container">
    <div class="status-bar">
        <div class="status-line">
            Controls: SPACE=mode P=pause S=single A=auto F=fit R=reset | Drag=pan Wheel=zoom
            <span class="serial-status disconnected" id="serialStatus">Serial: NOT CONNECTED</span>
        </div>
        <div class="status-line" id="statusInfo">
            Frame: 0 | FPS: 0.0 | Mode: 4.7K(T) [FIXED]
        </div>
    </div>

    <div class="plot-area">
        <div class="plot-container">
            <div class="plot-title" id="plotTitle">I-V Characteristics - Dual DUT Comparison [FIXED SCALE] Zoom:1.00x</div>
            <div class="axis-label-y">Current</div>
            <div class="canvas-wrapper">
                <canvas id="plotCanvas"></canvas>
                <div class="legend" id="legend">
                    <div class="legend-item">
                        <div class="legend-line dut1"></div>
                        <span>DUT1 (CH1 - Black Lead)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line dut2"></div>
                        <span>DUT2 (CH2 - Red Lead)</span>
                    </div>
                </div>
                <div class="pause-overlay" id="pauseOverlay">PAUSED</div>
            </div>
            <div class="axis-label-x">DUT Voltage</div>
        </div>
    </div>

    <div class="info-panel">
        <div class="info-line ch1" id="ch1Info">CH1 (DUT1 Current - Black Lead): No Data</div>
        <div class="info-line ch2" id="ch2Info">CH2 (DUT2 Current - Red Lead): No Data</div>
        <div class="info-line voltage" id="voltageInfo">DUT Voltages: No Data</div>
    </div>
</div>

<script>
// Check for Web Serial API support
if (!('serial' in navigator)) {
    alert('Web Serial API not supported in this browser. Use Chrome, Edge, Opera, (and other Chromium-based browsers).');
}

// Configuration
const config = {
    colors: {
        background: [0,0,0],
        dut1_trace: [50,150,255],
        dut2_trace: [255,50,50],
        dut1_dimmed: [25,75,128],
        dut2_dimmed: [128,25,25],
        grid_background: [30,30,30],
        grid: [50,50,50],
        crosshair: [255,255,50],
        label: [200,200,200],
        axis_title: [255,255,255],
        border: [100,100,100],
        dut_voltage: [50,255,150]
    },
    keybinds: {
        quit: 'q',
        pause: 'p',
        single_channel: 's',
        auto_scale: 'a',
        fit_window: 'f',
        reset_view: 'r',
        cycle_mode: 'space',
        settings: 'f1'
    },
    acq_rate: 20
};

// Serial port manager
class SerialPortManager {
    constructor() {
        this.port = null;
        this.reader = null;
        this.writer = null;
        this.isConnected = false;
        this.readBuffer = new Uint8Array(0);
    }

    async requestPort() {
        try {
            this.port = await navigator.serial.requestPort();
            return true;
        } catch (err) {
            console.error('Error requesting port:', err);
            return false;
        }
    }

    async connect(baudRate = 115200) {
        if (!this.port) {
            return false;
        }

        try {
            await this.port.open({
                baudRate: baudRate,
                dataBits: 8,
                stopBits: 1,
                parity: 'none',
                flowControl: 'none'
            });

            this.reader = this.port.readable.getReader();
            this.writer = this.port.writable.getWriter();
            this.isConnected = true;

            const info = this.port.getInfo();
            console.log('Connected to port:', info);

            return true;
        } catch (err) {
            console.error('Error opening port:', err);
            return false;
        }
    }

    async disconnect() {
        try {
            if (this.reader) {
                await this.reader.cancel();
                await this.reader.releaseLock();
                this.reader = null;
            }

            if (this.writer) {
                await this.writer.releaseLock();
                this.writer = null;
            }

            if (this.port) {
                await this.port.close();
                this.port = null;
            }

            this.isConnected = false;
            this.readBuffer = new Uint8Array(0);
            return true;
        } catch (err) {
            console.error('Error disconnecting:', err);
            return false;
        }
    }

    async write(data) {
        if (!this.writer) {
            throw new Error('Not connected');
        }

        const bytes = typeof data === 'string'
            ? new TextEncoder().encode(data)
            : data;

        await this.writer.write(bytes);
    }

    async read(numBytes, timeout = 500) {
        if (!this.reader) {
            throw new Error('Not connected');
        }

        const startTime = Date.now();
        let buffer = new Uint8Array(0);

        while (buffer.length < numBytes) {
            if (Date.now() - startTime > timeout) {
                throw new Error('Read timeout');
            }

            try {
                const { value, done } = await Promise.race([
                    this.reader.read(),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Read timeout')), timeout)
                    )
                ]);

                if (done) {
                    throw new Error('Stream closed');
                }

                if (value) {
                    const newBuffer = new Uint8Array(buffer.length + value.length);
                    newBuffer.set(buffer);
                    newBuffer.set(value, buffer.length);
                    buffer = newBuffer;
                }
            } catch (err) {
                if (buffer.length > 0) {
                    return buffer;
                }
                throw err;
            }
        }

        return buffer;
    }

    async acquire(mode = 'T') {
        if (!this.isConnected) {
            return null;
        }

        try {
            await this.write(mode);
            const data = await this.read(2016, 1000);

            if (data.length !== 2016) {
                console.warn(`Expected 2016 bytes, got ${data.length}`);
                return null;
            }

            const values = [];
            for (let i = 0; i < data.length; i += 2) {
                const val = (data[i] | (data[i + 1] << 8)) & 0x0FFF;
                values.push(val);
            }

            if (values.length !== 1008) {
                console.warn(`Expected 1008 values, got ${values.length}`);
                return null;
            }

            const driveVoltage = [];
            const ch1Raw = [];
            const ch2Raw = [];

            for (let i = 0; i < values.length; i += 3) {
                driveVoltage.push(values[i]);
                ch1Raw.push(values[i + 1]);
                ch2Raw.push(values[i + 2]);
            }

            const ch1Current = driveVoltage.map((v, i) => v - ch1Raw[i]);
            const ch2Current = driveVoltage.map((v, i) => v - ch2Raw[i]);

            return {
                ch1Voltage: ch1Raw,
                ch2Voltage: ch2Raw,
                ch1Current: ch1Current,
                ch2Current: ch2Current,
                driveVoltage: driveVoltage
            };

        } catch (err) {
            console.error('Acquisition error:', err);
            return null;
        }
    }

    getPortInfo() {
        if (!this.port) {
            return null;
        }
        return this.port.getInfo();
    }
}

// Initialize serial manager
const serialManager = new SerialPortManager();

// State
const state = {
    paused: false,
    singleChannel: false,
    autoScale: false,
    excitationMode: 0,
    zoom: 1.0,
    panX: 0,
    panY: 0,
    dragging: false,
    frameCount: 0,
    fps: 0,
    lastFrameTime: Date.now(),
    ch1: [],
    ch2: [],
    ch1Voltage: [],
    ch2Voltage: [],
    driveVoltage: [],
    ch1Std: [],
    ch2Std: [],
    ch1Voltage_Std: [],
    ch2Voltage_Std: [],
    ch1Weak: [],
    ch2Weak: [],
    ch1Voltage_Weak: [],
    ch2Voltage_Weak: [],
    altUseWeak: false,
    lastModeWasWeak: false
};

// Configuration
const ADC_MAX = 2800;
const ADC_ORIGIN = 2048;

// Canvas setup
const canvas = document.getElementById('plotCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const wrapper = canvas.parentElement;
    canvas.width = wrapper.clientWidth;
    canvas.height = wrapper.clientHeight;
    drawPlot();
}

window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Settings dialog
document.getElementById('settingsButton').addEventListener('click', () => {
    document.getElementById('settingsOverlay').classList.add('active');
});

document.getElementById('cancelButton').addEventListener('click', () => {
    document.getElementById('settingsOverlay').classList.remove('active');
});

document.getElementById('saveButton').addEventListener('click', () => {
    saveSettings();
    applySettings();
    document.getElementById('settingsOverlay').classList.remove('active');
});

// Tab switching
document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        button.classList.add('active');
        document.getElementById(tab + 'Panel').classList.add('active');

        const titles = {
            display: 'Display Settings',
            colors: 'Color Settings',
            keybinds: 'Keyboard Shortcuts',
            about: 'About WebCurveBug'
        };
        document.getElementById('settingsTitle').textContent = titles[tab];
    });
});

// Color picker
let currentColorKey = null;

document.querySelectorAll('.color-swatch').forEach(swatch => {
    swatch.addEventListener('click', () => {
        currentColorKey = swatch.dataset.color;
        const rgb = config.colors[currentColorKey];

        document.getElementById('redSlider').value = rgb[0];
        document.getElementById('greenSlider').value = rgb[1];
        document.getElementById('blueSlider').value = rgb[2];
        updateColorPreview();

        document.getElementById('colorPickerOverlay').classList.add('active');
        document.getElementById('colorPickerDialog').classList.add('active');
    });
});

function updateColorPreview() {
    const r = document.getElementById('redSlider').value;
    const g = document.getElementById('greenSlider').value;
    const b = document.getElementById('blueSlider').value;

    document.getElementById('redValue').textContent = r;
    document.getElementById('greenValue').textContent = g;
    document.getElementById('blueValue').textContent = b;
    document.getElementById('colorPreview').style.backgroundColor = `rgb(${r},${g},${b})`;
}

document.querySelectorAll('.color-slider').forEach(slider => {
    slider.addEventListener('input', updateColorPreview);
});

document.getElementById('pickerOK').addEventListener('click', () => {
    if (currentColorKey) {
        const r = parseInt(document.getElementById('redSlider').value);
        const g = parseInt(document.getElementById('greenSlider').value);
        const b = parseInt(document.getElementById('blueSlider').value);

        config.colors[currentColorKey] = [r, g, b];

        const swatch = document.querySelector(`[data-color="${currentColorKey}"]`);
        swatch.style.backgroundColor = `rgb(${r},${g},${b})`;
    }

    document.getElementById('colorPickerOverlay').classList.remove('active');
    document.getElementById('colorPickerDialog').classList.remove('active');
});

document.getElementById('pickerCancel').addEventListener('click', () => {
    document.getElementById('colorPickerOverlay').classList.remove('active');
    document.getElementById('colorPickerDialog').classList.remove('active');
});

// Add after the color picker event listeners

document.getElementById('darkModeButton').addEventListener('click', () => {
    config.colors = {
        background: [0,0,0],
        dut1_trace: [50,150,255],
        dut2_trace: [255,50,50],
        dut1_dimmed: [25,75,128],
        dut2_dimmed: [128,25,25],
        grid_background: [30,30,30],
        grid: [50,50,50],
        crosshair: [255,255,50],
        label: [200,200,200],
        axis_title: [255,255,255],
        border: [100,100,100],
        dut_voltage: [50,255,150]
    };
    applySettings();
});

document.getElementById('lightModeButton').addEventListener('click', () => {
    config.colors = {
        background: [240,240,240],
        dut1_trace: [0,100,220],
        dut2_trace: [220,50,50],
        dut1_dimmed: [150,180,230],
        dut2_dimmed: [230,150,150],
        grid_background: [255,255,255],
        grid: [200,200,200],
        crosshair: [200,150,0],
        label: [50,50,50],
        axis_title: [0,0,0],
        border: [150,150,150],
        dut_voltage: [0,150,100]
    };
    applySettings();
});

function saveSettings() {
    // Save keybinds
    config.keybinds.quit = document.getElementById('keyQuit').value.toLowerCase();
    config.keybinds.pause = document.getElementById('keyPause').value.toLowerCase();
    config.keybinds.single_channel = document.getElementById('keySingle').value.toLowerCase();
    config.keybinds.auto_scale = document.getElementById('keyAuto').value.toLowerCase();
    config.keybinds.fit_window = document.getElementById('keyFit').value.toLowerCase();
    config.keybinds.reset_view = document.getElementById('keyReset').value.toLowerCase();
    config.keybinds.cycle_mode = document.getElementById('keyCycle').value.toLowerCase();
    config.keybinds.settings = document.getElementById('keySettings').value.toLowerCase();

    // Save acquisition rate
    config.acq_rate = parseInt(document.getElementById('acqRate').value);

    // Save to localStorage
    localStorage.setItem('curvebug_config', JSON.stringify(config));
}

function applySettings() {
    // Update color swatches
    Object.keys(config.colors).forEach(key => {
        const swatch = document.querySelector(`[data-color="${key}"]`);
        if (swatch) {
            const rgb = config.colors[key];
            swatch.style.backgroundColor = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
        }
    });


    // Apply background color to body
    document.body.style.backgroundColor = `rgb(${config.colors.background.join(',')})`;

    // Apply axis title colors
    document.querySelectorAll('.axis-label-x, .axis-label-y').forEach(el => {
        el.style.color = `rgb(${config.colors.axis_title.join(',')})`;
    });

    // Apply border color to canvas
    document.querySelector('.canvas-wrapper').style.borderColor =
        `rgb(${config.colors.border.join(',')})`;

    // Update legend colors
    document.querySelector('.legend-line.dut1').style.backgroundColor =
        `rgb(${config.colors.dut1_trace.join(',')})`;
    document.querySelector('.legend-line.dut2').style.backgroundColor =
        `rgb(${config.colors.dut2_trace.join(',')})`;

    drawPlot();
}

function loadConfig() {
    const saved = localStorage.getItem('curvebug_config');
    if (saved) {
        const savedConfig = JSON.parse(saved);
        Object.assign(config, savedConfig);

        // Update UI with loaded values
        document.getElementById('acqRate').value = config.acq_rate;

        Object.keys(config.keybinds).forEach(key => {
            const input = document.getElementById('key' + key.charAt(0).toUpperCase() +
                key.slice(1).replace(/_./g, m => m[1].toUpperCase()));
            if (input) {
                input.value = config.keybinds[key];
            }
        });

        applySettings();
    }
}

// Connection UI
document.getElementById('connectButtonTop').addEventListener('click', () => {
    document.getElementById('connectionPanel').classList.remove('hidden');
});

document.getElementById('closeConnectionPanel').addEventListener('click', () => {
    document.getElementById('connectionPanel').classList.add('hidden');
});

document.getElementById('selectPortButton').addEventListener('click', async () => {
    const success = await serialManager.requestPort();
    if (success) {
        const connected = await serialManager.connect(115200);
        if (connected) {
            updateConnectionStatus(true);
            document.getElementById('connectionPanel').classList.add('hidden');
        } else {
            updateConnectionStatus(false);
            alert('Failed to connect to port');
        }
    }
});

document.getElementById('disconnectButton').addEventListener('click', async () => {
    await serialManager.disconnect();
    updateConnectionStatus(false);
});

function updateConnectionStatus(connected) {
    const statusEl = document.getElementById('connectionStatus');
    const serialStatusEl = document.getElementById('serialStatus');
    const portInfoEl = document.getElementById('portInfo');
    const disconnectBtn = document.getElementById('disconnectButton');
    const selectBtn = document.getElementById('selectPortButton');
    const topBtn = document.getElementById('connectButtonTop');

    if (connected) {
        statusEl.textContent = 'Connected';
        statusEl.style.backgroundColor = '#32ff96';
        statusEl.style.color = '#000000';

        serialStatusEl.textContent = 'Serial: Connected';
        serialStatusEl.className = 'serial-status connected';

        const info = serialManager.getPortInfo();
        portInfoEl.textContent = `Port: USB VID=${info.usbVendorId || 'N/A'} PID=${info.usbProductId || 'N/A'}`;

        disconnectBtn.classList.remove('hidden');
        selectBtn.classList.add('hidden');

        topBtn.textContent = 'Connected';
        topBtn.classList.add('connected');
    } else {
        statusEl.textContent = 'Not connected';
        statusEl.style.backgroundColor = '#323232';
        statusEl.style.color = '#ffffff';

        serialStatusEl.textContent = 'Serial: NOT CONNECTED';
        serialStatusEl.className = 'serial-status disconnected';

        portInfoEl.textContent = 'Click below to select a serial port';

        disconnectBtn.classList.add('hidden');
        selectBtn.classList.remove('hidden');

        topBtn.textContent = 'Connect Serial';
        topBtn.classList.remove('connected');
    }
}

// Data acquisition
async function acquireData() {
    if (!serialManager.isConnected || state.paused) {
        return;
    }

    let command = 'T';
    let storeAsWeak = false;

    if (state.excitationMode === 0) {
        command = 'T';
        storeAsWeak = false;
    } else if (state.excitationMode === 1) {
        command = 'W';
        storeAsWeak = true;
    } else {
        if (state.altUseWeak) {
            command = 'W';
            storeAsWeak = true;
        } else {
            command = 'T';
            storeAsWeak = false;
        }
        state.altUseWeak = !state.altUseWeak;
    }

    const data = await serialManager.acquire(command);

    if (data) {
        if (storeAsWeak) {
            state.ch1Weak = data.ch1Current;
            state.ch2Weak = data.ch2Current;
            state.ch1Voltage_Weak = data.ch1Voltage;
            state.ch2Voltage_Weak = data.ch2Voltage;
            state.lastModeWasWeak = true;
        } else {
            state.ch1Std = data.ch1Current;
            state.ch2Std = data.ch2Current;
            state.ch1Voltage_Std = data.ch1Voltage;
            state.ch2Voltage_Std = data.ch2Voltage;
            state.lastModeWasWeak = false;
        }

        if (storeAsWeak) {
            state.ch1 = state.ch1Weak;
            state.ch2 = state.ch2Weak;
            state.ch1Voltage = state.ch1Voltage_Weak;
            state.ch2Voltage = state.ch2Voltage_Weak;
        } else {
            state.ch1 = state.ch1Std;
            state.ch2 = state.ch2Std;
            state.ch1Voltage = state.ch1Voltage_Std;
            state.ch2Voltage = state.ch2Voltage_Std;
        }

        state.driveVoltage = data.driveVoltage;
        state.frameCount++;

        updateInfoPanel();
    }
}

function updateInfoPanel() {
    if (state.ch1.length > 0) {
        const ch1Min = Math.min(...state.ch1);
        const ch1Max = Math.max(...state.ch1);
        const ch1Mean = state.ch1.reduce((a, b) => a + b, 0) / state.ch1.length;

        document.getElementById('ch1Info').textContent =
            `CH1 (DUT1 Current - Black Lead): ${ch1Min.toFixed(0)}-${ch1Max.toFixed(0)}  Mean: ${ch1Mean.toFixed(0)}  Points: ${state.ch1.length}`;
        document.getElementById('ch1Info').style.color =
            `rgb(${config.colors.dut1_trace.join(',')})`;

        const ch2Min = Math.min(...state.ch2);
        const ch2Max = Math.max(...state.ch2);
        const ch2Mean = state.ch2.reduce((a, b) => a + b, 0) / state.ch2.length;

        document.getElementById('ch2Info').textContent =
            `CH2 (DUT2 Current - Red Lead): ${ch2Min.toFixed(0)}-${ch2Max.toFixed(0)}  Mean: ${ch2Mean.toFixed(0)}  Points: ${state.ch2.length}`;
        document.getElementById('ch2Info').style.color =
            `rgb(${config.colors.dut2_trace.join(',')})`;

        const v1Min = Math.min(...state.ch1Voltage);
        const v1Max = Math.max(...state.ch1Voltage);
        const v2Min = Math.min(...state.ch2Voltage);
        const v2Max = Math.max(...state.ch2Voltage);
        const dMin = Math.min(...state.driveVoltage);
        const dMax = Math.max(...state.driveVoltage);

        document.getElementById('voltageInfo').textContent =
            `DUT Voltages: V1=${v1Min.toFixed(0)}-${v1Max.toFixed(0)}, V2=${v2Min.toFixed(0)}-${v2Max.toFixed(0)}, Drive=${dMin.toFixed(0)}-${dMax.toFixed(0)}`;
        document.getElementById('voltageInfo').style.color =
            `rgb(${config.colors.dut_voltage.join(',')})`;
    }
}

// Draw plot
function drawPlot() {
    const w = canvas.width;
    const h = canvas.height;
    const paddingLeft = 50;
    const paddingRight = 50;
    const paddingTop = 20;
    const paddingBottom = 50;
    const plotX = paddingLeft;
    const plotY = paddingTop;
    const plotW = w - paddingLeft - paddingRight;
    const plotH = h - paddingTop - paddingBottom;

    // Background
    ctx.fillStyle = `rgb(${config.colors.grid_background.join(',')})`;
    ctx.fillRect(0, 0, w, h);

    // Grid
    ctx.strokeStyle = `rgb(${config.colors.grid.join(',')})`;
    ctx.lineWidth = 1;
    for (let i = 0; i <= 10; i++) {
        const x = plotX + (i / 10) * plotW;
        const y = plotY + (i / 10) * plotH;
        ctx.beginPath();
        ctx.moveTo(x, plotY);
        ctx.lineTo(x, plotY + plotH);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(plotX, y);
        ctx.lineTo(plotX + plotW, y);
        ctx.stroke();
    }

    // Calculate scale
    let xMin, xMax, yMin, yMax;

    if (state.autoScale && state.ch1.length > 0) {
        xMin = Math.min(...state.ch1Voltage, ...state.ch2Voltage);
        xMax = Math.max(...state.ch1Voltage, ...state.ch2Voltage);
        yMin = Math.min(...state.ch1, ...state.ch2);
        yMax = Math.max(...state.ch1, ...state.ch2);

        const xMargin = (xMax - xMin) * 0.1 || 100;
        const yMargin = (yMax - yMin) * 0.1 || 100;
        xMin -= xMargin;
        xMax += xMargin;
        yMin -= yMargin;
        yMax += yMargin;
    } else {
        const yRange = ADC_MAX - 700;
        const baseYMax = yRange / 8;
        const baseYMin = -yRange * 7 / 8;

        const xRangeVisible = ADC_MAX / state.zoom;
        const yRangeVisible = (baseYMax - baseYMin) / state.zoom;

        const xCenter = ADC_MAX / 2 + state.panX;
        const yCenter = (baseYMax + baseYMin) / 2 + state.panY;

        xMin = xCenter - xRangeVisible / 2;
        xMax = xCenter + xRangeVisible / 2;
        yMin = yCenter - yRangeVisible / 2;
        yMax = yCenter + yRangeVisible / 2;
    }

    // Crosshair at origin
    ctx.strokeStyle = `rgb(${config.colors.crosshair.join(',')})`;
    ctx.lineWidth = 2;

    const zeroXNorm = (ADC_ORIGIN - xMin) / (xMax - xMin);
    const zeroYNorm = (0 - yMin) / (yMax - yMin);

    if (zeroXNorm >= 0 && zeroXNorm <= 1) {
        const zeroX = plotX + plotW - (zeroXNorm * plotW);
        ctx.beginPath();
        ctx.moveTo(zeroX, plotY);
        ctx.lineTo(zeroX, plotY + plotH);
        ctx.stroke();
    }

    if (zeroYNorm >= 0 && zeroYNorm <= 1) {
        const zeroY = plotY + (zeroYNorm * plotH);
        ctx.beginPath();
        ctx.moveTo(plotX, zeroY);
        ctx.lineTo(plotX + plotW, zeroY);
        ctx.stroke();
    }

    // Draw traces (helper function updated below)
    if (state.ch1.length > 0) {
        if (state.excitationMode === 2 && state.ch1Std.length > 0 && state.ch1Weak.length > 0) {
            if (state.lastModeWasWeak) {
                drawTrace(state.ch1Voltage_Std, state.ch1Std, config.colors.dut1_dimmed, xMin, xMax, yMin, yMax, 2, plotX, plotW, plotY, plotH);
                drawTrace(state.ch1Voltage_Weak, state.ch1Weak, config.colors.dut1_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
                if (!state.singleChannel) {
                    drawTrace(state.ch2Voltage_Std, state.ch2Std, config.colors.dut2_dimmed, xMin, xMax, yMin, yMax, 2, plotX, plotW, plotY, plotH);
                    drawTrace(state.ch2Voltage_Weak, state.ch2Weak, config.colors.dut2_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
                }
            } else {
                drawTrace(state.ch1Voltage_Weak, state.ch1Weak, config.colors.dut1_dimmed, xMin, xMax, yMin, yMax, 2, plotX, plotW, plotY, plotH);
                drawTrace(state.ch1Voltage_Std, state.ch1Std, config.colors.dut1_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
                if (!state.singleChannel) {
                    drawTrace(state.ch2Voltage_Weak, state.ch2Weak, config.colors.dut2_dimmed, xMin, xMax, yMin, yMax, 2, plotX, plotW, plotY, plotH);
                    drawTrace(state.ch2Voltage_Std, state.ch2Std, config.colors.dut2_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
                }
            }
        } else {
            drawTrace(state.ch1Voltage, state.ch1, config.colors.dut1_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
            if (!state.singleChannel) {
                drawTrace(state.ch2Voltage, state.ch2, config.colors.dut2_trace, xMin, xMax, yMin, yMax, 3, plotX, plotW, plotY, plotH);
            }
        }
    } else {
        ctx.fillStyle = `rgb(${config.colors.axis_title.join(',')})`;
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('No Data - Connect Serial and Start Acquisition', plotX + plotW / 2, plotY + plotH / 2);
    }

    // Axis labels
    ctx.fillStyle = `rgb(${config.colors.label.join(',')})`;
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';

    for (let i of [0, 5, 10]) {
        const xVal = xMin + (xMax - xMin) * (10 - i) / 10;
        const x = plotX + (i / 10) * plotW;
        ctx.fillText(xVal.toFixed(0), x, plotY + plotH + 20);
    }

    ctx.textAlign = 'right';
    for (let i of [0, 5, 10]) {
        const yVal = yMin + (yMax - yMin) * i / 10;
        const y = plotY + (i / 10) * plotH;
        ctx.fillText(yVal.toFixed(0), plotX - 5, y + 4);
    }
}

function drawTrace(voltages, currents, color, xMin, xMax, yMin, yMax, lineWidth, plotX, plotW, plotY, plotH) {
    if (voltages.length === 0) return;

    ctx.strokeStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
    ctx.lineWidth = lineWidth;
    ctx.beginPath();

    let started = false;
    for (let i = 0; i < voltages.length; i++) {
        const xNorm = (voltages[i] - xMin) / (xMax - xMin);
        const yNorm = (currents[i] - yMin) / (yMax - yMin);

        const x = plotX + plotW - (xNorm * plotW);
        const y = plotY + (yNorm * plotH);

        if (!started) {
            ctx.moveTo(x, y);
            started = true;
        } else {
            ctx.lineTo(x, y);
        }
    }

    ctx.stroke();
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
    // Don't process keys if settings overlay is active
    if (document.getElementById('settingsOverlay').classList.contains('active')) {
        if (e.key === 'Escape') {
            document.getElementById('settingsOverlay').classList.remove('active');
        }
        return;
    }

    const key = e.key.toLowerCase();

    if (key === config.keybinds.pause || key === 'p') {
        state.paused = !state.paused;
        document.getElementById('pauseOverlay').classList.toggle('active', state.paused);
    } else if (key === config.keybinds.single_channel || key === 's') {
        state.singleChannel = !state.singleChannel;
        document.querySelector('.legend-item:last-child').style.display =
            state.singleChannel ? 'none' : 'flex';
        drawPlot();
    } else if (key === config.keybinds.auto_scale || key === 'a') {
        state.autoScale = !state.autoScale;
        updatePlotTitle();
        drawPlot();
    } else if (key === config.keybinds.reset_view || key === 'r') {
        state.zoom = 1.0;
        state.panX = 0;
        state.panY = 0;
        updatePlotTitle();
        drawPlot();
    } else if (key === config.keybinds.fit_window || key === 'f') {
        fitToWindow();
    } else if (e.key === ' ' || key === config.keybinds.cycle_mode) {
        e.preventDefault();
        state.excitationMode = (state.excitationMode + 1) % 3;
        updateStatusInfo();
    } else if (e.key === 'F1' || key === config.keybinds.settings) {
        e.preventDefault();
        document.getElementById('settingsOverlay').classList.add('active');
    }
});

function fitToWindow() {
    if (state.autoScale || state.ch1.length === 0) return;

    let allX, allY;

    if (state.excitationMode === 2 && state.ch1Std.length > 0 && state.ch1Weak.length > 0) {
        allX = [...state.ch1Voltage_Std, ...state.ch2Voltage_Std, ...state.ch1Voltage_Weak, ...state.ch2Voltage_Weak];
        allY = [...state.ch1Std, ...state.ch2Std, ...state.ch1Weak, ...state.ch2Weak];
    } else {
        allX = [...state.ch1Voltage, ...state.ch2Voltage];
        allY = [...state.ch1, ...state.ch2];
    }

    const dataXMin = Math.min(...allX);
    const dataXMax = Math.max(...allX);
    const dataYMin = Math.min(...allY);
    const dataYMax = Math.max(...allY);

    const xMargin = (dataXMax - dataXMin) * 0.2;
    const yMargin = (dataYMax - dataYMin) * 0.2;

    const dataXRange = (dataXMax - dataXMin) + 2 * xMargin;
    const dataYRange = (dataYMax - dataYMin) + 2 * yMargin;

    const yRange = ADC_MAX - 700;
    const baseYMax = yRange / 8;
    const baseYMin = -yRange * 7 / 8;
    const baseXRange = ADC_MAX;
    const baseYRange = baseYMax - baseYMin;

    const zoomX = baseXRange / dataXRange;
    const zoomY = baseYRange / dataYRange;

    state.zoom = Math.min(zoomX, zoomY, 1.0);

    const dataXCenter = (dataXMin + dataXMax) / 2;
    const dataYCenter = (dataYMin + dataYMax) / 2;
    const baseXCenter = ADC_MAX / 2;
    const baseYCenter = (baseYMax + baseYMin) / 2;

    state.panX = dataXCenter - baseXCenter;
    state.panY = dataYCenter - baseYCenter;

    updatePlotTitle();
    drawPlot();
}

// Mouse controls
let dragStart = null;
let panStart = null;

canvas.addEventListener('mousedown', (e) => {
    if (state.autoScale) return;
    dragStart = { x: e.offsetX, y: e.offsetY };
    panStart = { x: state.panX, y: state.panY };
    state.dragging = true;
});

canvas.addEventListener('mousemove', (e) => {
    if (!state.dragging || state.autoScale) return;

    const dx = e.offsetX - dragStart.x;
    const dy = e.offsetY - dragStart.y;

    const w = canvas.width;
    const h = canvas.height;

    const xRangeVisible = ADC_MAX / state.zoom;
    const yRangeVisible = (ADC_MAX - 700) / state.zoom;

    state.panX = panStart.x + (dx * xRangeVisible / w);
    state.panY = panStart.y - (dy * yRangeVisible / h);

    drawPlot();
});

// Listen on document instead of just canvas to catch mouseup outside viewport
document.addEventListener('mouseup', () => {
    state.dragging = false;
});

// Also reset on mouse leaving the window
document.addEventListener('mouseleave', () => {
    state.dragging = false;
});

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    if (state.autoScale) return;

    if (e.deltaY < 0) {
        state.zoom *= 1.2;
    } else {
        state.zoom /= 1.2;
        state.zoom = Math.max(0.1, state.zoom);
    }

    updatePlotTitle();
    drawPlot();
});

function updatePlotTitle() {
    const mode = state.autoScale ? 'AUTO-SCALE' : `FIXED SCALE] Zoom:${state.zoom.toFixed(2)}x`;
    document.getElementById('plotTitle').textContent =
        `I-V Characteristics - Dual DUT Comparison [${mode}`;
}

function updateStatusInfo() {
    const modeNames = ['4.7K(T)', '100K WEAK(W)', 'ALT'];
    let modeStr = modeNames[state.excitationMode];

    if (state.excitationMode === 2 && state.ch1.length > 0) {
        modeStr = state.lastModeWasWeak ? 'ALT[W-bright T-dim]' : 'ALT[T-bright W-dim]';
    }

    const scaleMode = state.autoScale ? 'AUTO' : 'FIXED';
    const pauseStr = state.paused ? ' [PAUSED]' : '';
    const singleStr = state.singleChannel ? ' [SINGLE CH]' : '';

    document.getElementById('statusInfo').textContent =
        `Frame: ${state.frameCount} | FPS: ${state.fps.toFixed(1)} | Mode: ${modeStr}${pauseStr}${singleStr} [${scaleMode}]`;
}

// Animation loop
let animationFrameId = null;

async function animate() {
    const now = Date.now();
    const dt = (now - state.lastFrameTime) / 1000;
    state.lastFrameTime = now;

    if (dt > 0) {
        state.fps = 1 / dt;
    }

    // Acquire data if connected and not paused
    if (serialManager.isConnected && !state.paused) {
        await acquireData();
    }

    drawPlot();
    updateStatusInfo();

    // Use configurable frame rate
    const targetInterval = 1000 / config.acq_rate;
    setTimeout(() => {
        animationFrameId = requestAnimationFrame(animate);
    }, targetInterval);
}

// Start
loadConfig();
animate();
</script>

</body>
</html>